//
//  RepositoryTests-RepositoryMocks.generated.swift
//  Repository
//
//  Generated by Mockingbird v0.18.1.
//  DO NOT EDIT
//

@testable import Mockingbird
@testable import Repository
import Combine
import Foundation
import Swift
private let genericStaticMockContext = Mockingbird.GenericStaticMockContext()

// MARK: - Mocked ContactApi
public final class ContactApiMock: ContactApi, Mockingbird.Mock {
  typealias MockingbirdSupertype = ContactApi
  static let staticMock = Mockingbird.StaticMock()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.18.1", "module_name": "Repository"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    ContactApiMock.staticMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `fetchContacts`(withSize `size`: Int)
  public func `fetchContacts`(withSize `size`: Int) -> AnyPublisher<[Contact], Error> {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`fetchContacts`(withSize `size`: Int) -> AnyPublisher<[Contact], Error>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`size`)], returnType: Swift.ObjectIdentifier((AnyPublisher<[Contact], Error>).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? (Int) -> AnyPublisher<[Contact], Error> { return mkbImpl(`size`) }
      if let mkbImpl = mkbImpl as? () -> AnyPublisher<[Contact], Error> { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: AnyPublisher<[Contact], Error> = mkbObject.`fetchContacts`(withSize: `size`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (AnyPublisher<[Contact], Error>).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `fetchContacts`(withSize `size`: @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int) -> AnyPublisher<[Contact], Error>, AnyPublisher<[Contact], Error>> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, (Int) -> AnyPublisher<[Contact], Error>, AnyPublisher<[Contact], Error>>(mock: self, invocation: Mockingbird.SwiftInvocation(selectorName: "`fetchContacts`(withSize `size`: Int) -> AnyPublisher<[Contact], Error>", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`size`)], returnType: Swift.ObjectIdentifier((AnyPublisher<[Contact], Error>).self)))
  }
}

/// Returns a concrete mock of `ContactApi`.
public func mock(_ type: ContactApi.Protocol, file: StaticString = #file, line: UInt = #line) -> ContactApiMock {
  return ContactApiMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}

// MARK: - Mocked ContactDao
public final class ContactDaoMock: ContactDao, Mockingbird.Mock {
  typealias MockingbirdSupertype = ContactDao
  static let staticMock = Mockingbird.StaticMock()
  public let mockingbirdContext = Mockingbird.Context(["generator_version": "0.18.1", "module_name": "Repository"])

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    self.mockingbirdContext.sourceLocation = sourceLocation
    ContactDaoMock.staticMock.mockingbirdContext.sourceLocation = sourceLocation
  }

  // MARK: Mocked `clearCachedContacts`()
  public func `clearCachedContacts`() -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`clearCachedContacts`() -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`clearCachedContacts`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `clearCachedContacts`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> Void, Void>(mock: self, invocation: Mockingbird.SwiftInvocation(selectorName: "`clearCachedContacts`() -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  // MARK: Mocked `cacheContacts`(`contacts`: [Contact])
  public func `cacheContacts`(`contacts`: [Contact]) -> Void {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`cacheContacts`(`contacts`: [Contact]) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.ArgumentMatcher(`contacts`)], returnType: Swift.ObjectIdentifier((Void).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? ([Contact]) -> Void { return mkbImpl(`contacts`) }
      if let mkbImpl = mkbImpl as? () -> Void { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: Void = mkbObject.`cacheContacts`(contacts: `contacts`)
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: (Void).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `cacheContacts`(`contacts`: @autoclosure () -> [Contact]) -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, ([Contact]) -> Void, Void> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, ([Contact]) -> Void, Void>(mock: self, invocation: Mockingbird.SwiftInvocation(selectorName: "`cacheContacts`(`contacts`: [Contact]) -> Void", selectorType: Mockingbird.SelectorType.method, arguments: [Mockingbird.resolve(`contacts`)], returnType: Swift.ObjectIdentifier((Void).self)))
  }

  // MARK: Mocked `getCachedContacts`()
  public func `getCachedContacts`() -> [Contact]? {
    return self.mockingbirdContext.mocking.didInvoke(Mockingbird.SwiftInvocation(selectorName: "`getCachedContacts`() -> [Contact]?", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier(([Contact]?).self))) {
      self.mockingbirdContext.recordInvocation($0)
      let mkbImpl = self.mockingbirdContext.stubbing.implementation(for: $0)
      if let mkbImpl = mkbImpl as? () -> [Contact]? { return mkbImpl() }
      for mkbTargetBox in self.mockingbirdContext.proxy.targets(for: $0) {
        switch mkbTargetBox.target {
        case .super:
          break
        case .object(let mkbObject):
          guard var mkbObject = mkbObject as? MockingbirdSupertype else { break }
          let mkbValue: [Contact]? = mkbObject.`getCachedContacts`()
          self.mockingbirdContext.proxy.updateTarget(&mkbObject, in: mkbTargetBox)
          return mkbValue
        }
      }
      if let mkbValue = self.mockingbirdContext.stubbing.defaultValueProvider.value.provideValue(for: ([Contact]?).self) { return mkbValue }
      self.mockingbirdContext.stubbing.failTest(for: $0, at: self.mockingbirdContext.sourceLocation)
    }
  }

  public func `getCachedContacts`() -> Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> [Contact]?, [Contact]?> {
    return Mockingbird.Mockable<Mockingbird.FunctionDeclaration, () -> [Contact]?, [Contact]?>(mock: self, invocation: Mockingbird.SwiftInvocation(selectorName: "`getCachedContacts`() -> [Contact]?", selectorType: Mockingbird.SelectorType.method, arguments: [], returnType: Swift.ObjectIdentifier(([Contact]?).self)))
  }
}

/// Returns a concrete mock of `ContactDao`.
public func mock(_ type: ContactDao.Protocol, file: StaticString = #file, line: UInt = #line) -> ContactDaoMock {
  return ContactDaoMock(sourceLocation: Mockingbird.SourceLocation(file, line))
}
